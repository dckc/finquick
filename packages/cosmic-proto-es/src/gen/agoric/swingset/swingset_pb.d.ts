// @generated by protoc-gen-es v1.5.0
// @generated from file agoric/swingset/swingset.proto (package agoric.swingset, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Coin } from "../../cosmos/base/v1beta1/coin_pb.js";

/**
 * CoreEvalProposal is a gov Content type for evaluating code in the SwingSet
 * core.
 * See `agoric-sdk/packages/vats/src/core/eval.js`.
 *
 * @generated from message agoric.swingset.CoreEvalProposal
 */
export declare class CoreEvalProposal extends Message<CoreEvalProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title: string;

  /**
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * Although evals are sequential, they may run concurrently, since they each
   * can return a Promise.
   *
   * @generated from field: repeated agoric.swingset.CoreEval evals = 3;
   */
  evals: CoreEval[];

  constructor(data?: PartialMessage<CoreEvalProposal>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "agoric.swingset.CoreEvalProposal";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CoreEvalProposal;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CoreEvalProposal;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CoreEvalProposal;

  static equals(a: CoreEvalProposal | PlainMessage<CoreEvalProposal> | undefined, b: CoreEvalProposal | PlainMessage<CoreEvalProposal> | undefined): boolean;
}

/**
 * CoreEval defines an individual SwingSet core evaluation, for use in
 * CoreEvalProposal.
 *
 * @generated from message agoric.swingset.CoreEval
 */
export declare class CoreEval extends Message<CoreEval> {
  /**
   * Grant these JSON-stringified core bootstrap permits to the jsCode, as the
   * `powers` endowment.
   *
   * @generated from field: string json_permits = 1;
   */
  jsonPermits: string;

  /**
   * Evaluate this JavaScript code in a Compartment endowed with `powers` as
   * well as some powerless helpers.
   *
   * @generated from field: string js_code = 2;
   */
  jsCode: string;

  constructor(data?: PartialMessage<CoreEval>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "agoric.swingset.CoreEval";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CoreEval;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CoreEval;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CoreEval;

  static equals(a: CoreEval | PlainMessage<CoreEval> | undefined, b: CoreEval | PlainMessage<CoreEval> | undefined): boolean;
}

/**
 * Params are the swingset configuration/governance parameters.
 *
 * @generated from message agoric.swingset.Params
 */
export declare class Params extends Message<Params> {
  /**
   * Map from unit name to a value in SwingSet "beans".
   * Must not be negative.
   *
   * These values are used by SwingSet to normalize named per-resource charges
   * (maybe rent) in a single Nat usage unit, the "bean".
   *
   * There is no required order to this list of entries, but all the chain
   * nodes must all serialize and deserialize the existing order without
   * permuting it.
   *
   * @generated from field: repeated agoric.swingset.StringBeans beans_per_unit = 1;
   */
  beansPerUnit: StringBeans[];

  /**
   * The price in Coins per the unit named "fee".  This value is used by
   * cosmic-swingset JS code to decide how many tokens to charge.
   *
   * cost = beans_used * fee_unit_price / beans_per_unit["fee"]
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin fee_unit_price = 2;
   */
  feeUnitPrice: Coin[];

  /**
   * The SwingSet bootstrap vat configuration file.  Not usefully modifiable
   * via governance as it is only referenced by the chain's initial
   * construction.
   *
   * @generated from field: string bootstrap_vat_config = 3;
   */
  bootstrapVatConfig: string;

  /**
   * If the provision submitter doesn't hold a provisionpass, their requested
   * power flags are looked up in this fee menu (first match wins) and the sum
   * is charged.  If any power flag is not found in this menu, the request is
   * rejected.
   *
   * @generated from field: repeated agoric.swingset.PowerFlagFee power_flag_fees = 4;
   */
  powerFlagFees: PowerFlagFee[];

  /**
   * Maximum sizes for queues.
   * These values are used by SwingSet to compute how many messages should be
   * accepted in a block.
   *
   * There is no required order to this list of entries, but all the chain
   * nodes must all serialize and deserialize the existing order without
   * permuting it.
   *
   * @generated from field: repeated agoric.swingset.QueueSize queue_max = 5;
   */
  queueMax: QueueSize[];

  constructor(data?: PartialMessage<Params>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "agoric.swingset.Params";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Params;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Params;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Params;

  static equals(a: Params | PlainMessage<Params> | undefined, b: Params | PlainMessage<Params> | undefined): boolean;
}

/**
 * The current state of the module.
 *
 * @generated from message agoric.swingset.State
 */
export declare class State extends Message<State> {
  /**
   * The allowed number of items to add to queues, as determined by SwingSet.
   * Transactions which attempt to enqueue more should be rejected.
   *
   * @generated from field: repeated agoric.swingset.QueueSize queue_allowed = 1;
   */
  queueAllowed: QueueSize[];

  constructor(data?: PartialMessage<State>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "agoric.swingset.State";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): State;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): State;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): State;

  static equals(a: State | PlainMessage<State> | undefined, b: State | PlainMessage<State> | undefined): boolean;
}

/**
 * Map element of a string key to a Nat bean count.
 *
 * @generated from message agoric.swingset.StringBeans
 */
export declare class StringBeans extends Message<StringBeans> {
  /**
   * What the beans are for.
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * The actual bean value.
   *
   * @generated from field: string beans = 2;
   */
  beans: string;

  constructor(data?: PartialMessage<StringBeans>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "agoric.swingset.StringBeans";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringBeans;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringBeans;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringBeans;

  static equals(a: StringBeans | PlainMessage<StringBeans> | undefined, b: StringBeans | PlainMessage<StringBeans> | undefined): boolean;
}

/**
 * Map a provisioning power flag to its corresponding fee.
 *
 * @generated from message agoric.swingset.PowerFlagFee
 */
export declare class PowerFlagFee extends Message<PowerFlagFee> {
  /**
   * @generated from field: string power_flag = 1;
   */
  powerFlag: string;

  /**
   * @generated from field: repeated cosmos.base.v1beta1.Coin fee = 2;
   */
  fee: Coin[];

  constructor(data?: PartialMessage<PowerFlagFee>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "agoric.swingset.PowerFlagFee";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PowerFlagFee;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PowerFlagFee;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PowerFlagFee;

  static equals(a: PowerFlagFee | PlainMessage<PowerFlagFee> | undefined, b: PowerFlagFee | PlainMessage<PowerFlagFee> | undefined): boolean;
}

/**
 * Map element of a string key to a size.
 *
 * @generated from message agoric.swingset.QueueSize
 */
export declare class QueueSize extends Message<QueueSize> {
  /**
   * What the size is for.
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * The actual size value.
   *
   * @generated from field: int32 size = 2;
   */
  size: number;

  constructor(data?: PartialMessage<QueueSize>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "agoric.swingset.QueueSize";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueueSize;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueueSize;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueueSize;

  static equals(a: QueueSize | PlainMessage<QueueSize> | undefined, b: QueueSize | PlainMessage<QueueSize> | undefined): boolean;
}

/**
 * Egress is the format for a swingset egress.
 *
 * @generated from message agoric.swingset.Egress
 */
export declare class Egress extends Message<Egress> {
  /**
   * @generated from field: string nickname = 1;
   */
  nickname: string;

  /**
   * @generated from field: bytes peer = 2;
   */
  peer: Uint8Array;

  /**
   * TODO: Remove these power flags as they are deprecated and have no effect.
   *
   * @generated from field: repeated string power_flags = 3;
   */
  powerFlags: string[];

  constructor(data?: PartialMessage<Egress>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "agoric.swingset.Egress";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Egress;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Egress;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Egress;

  static equals(a: Egress | PlainMessage<Egress> | undefined, b: Egress | PlainMessage<Egress> | undefined): boolean;
}

/**
 * SwingStoreArtifact encodes an artifact of a swing-store export.
 * Artifacts may be stored or transmitted in any order. Most handlers do
 * maintain the artifact order from their original source as an effect of how
 * they handle the artifacts.
 *
 * @generated from message agoric.swingset.SwingStoreArtifact
 */
export declare class SwingStoreArtifact extends Message<SwingStoreArtifact> {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: bytes data = 2;
   */
  data: Uint8Array;

  constructor(data?: PartialMessage<SwingStoreArtifact>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "agoric.swingset.SwingStoreArtifact";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwingStoreArtifact;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwingStoreArtifact;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwingStoreArtifact;

  static equals(a: SwingStoreArtifact | PlainMessage<SwingStoreArtifact> | undefined, b: SwingStoreArtifact | PlainMessage<SwingStoreArtifact> | undefined): boolean;
}

